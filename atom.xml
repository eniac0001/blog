<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Victory's Blog]]></title>
  <link href="http://eniac0001.github.io/blog/atom.xml" rel="self"/>
  <link href="http://eniac0001.github.io/blog/"/>
  <updated>2013-12-06T20:36:33+08:00</updated>
  <id>http://eniac0001.github.io/blog/</id>
  <author>
    <name><![CDATA[VictoryZhang(CN)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于 CPU Cache 的一些事]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/11/28/cpu-cache/"/>
    <updated>2013-11-28T19:00:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/11/28/cpu-cache</id>
    <content type="html"><![CDATA[<p>本文摘自于博文《漫游处理器缓存效应》，文章不仅仅用7个最简单的源码示例就将CPU cache的原理娓娓道来，还附加图表量化分析做数学上的佐证。很好的诠释了 CPU Cache 的一些知识。</p>

<p>大多数读者都知道cache是一种快速小型的内存，用以存储最近访问内存位置。这种描述合理而准确，但是更多地了解一些处理器缓存工作中的“烦人”细节对于理解程序运行性能有很大帮助。</p>

<p>下面的例子都是用C#写的，但语言的选择同程序运行状况以及得出的结论几乎没什么影响。</p>

<h4>示例1：内存访问和运行</h4>

<pre><code>int[] arr = new int[64 * 1024 * 1024];

// Loop 1
for (int i = 0; i &lt; arr.Length; i++) arr[i] *= 3;

// Loop 2
for (int i = 0; i &lt; arr.Length; i += 16) arr[i] *= 3;
</code></pre>

<p>第一个循环将数组的每个值乘3，第二个循环将每16个值乘3，第二个循环只做了第一个约6%的工作，但在现代机器上，两者几乎运行相同时间：在我机器上分别是80毫秒和78毫秒。</p>

<p>两个循环花费相同时间的原因跟内存有关。<strong>循环执行时间长短由数组的内存访问次数决定的，而非整型数的乘法运算次数。</strong>经过下面对第二个示例的解释，你会发现硬件对这两个循环的主存访问次数是相同的。</p>

<h4>示例2：缓存行的影响</h4>

<p>让我们进一步探索这个例子。我们将尝试不同的循环步长，而不仅仅是1和16。</p>

<pre><code>for (int i = 0; i &lt; arr.Length; i += K) arr[i] *= 3;
</code></pre>

<p>下图为该循环在不同步长(K)下的运行时间：</p>

<p><img src="http://eniac0001.github.io/blog/images/blog/201311281.png" alt="image" /></p>

<p>注意当步长在1到16范围内，循环运行时间几乎不变。但从16开始，每次步长加倍，运行时间减半。</p>

<p>背后的原因是今天的CPU不再是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。</p>

<p>由于16个整型数占用64字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：即数组中所有的缓存行。当步长为32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。</p>

<p>理解缓存行对某些类型的程序优化而言可能很重要。比如，数据字节对齐可能决定一次操作接触1个还是2个缓存行。那上面的例子来说，很显然操作不对齐的数据将损失一半性能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS 架构]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/05/27/css-architecture/"/>
    <updated>2013-05-27T22:51:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/05/27/css-architecture</id>
    <content type="html"><![CDATA[<p>对于很多WEB开发者来说，很好的运用CSS意味着你可以使用一个模型（you can take a visual mock-up），并能够很好的复用它。你不使用表（tables），并且尽量少的使用图片。如果你觉得你很强大，你要能够运用最新的技术，例如媒体查询（media queries）、渐变（transitions）、变换（transforms）等。尽管对一个高超的CSS开发者来说，这些都是必须的，但有一方面在判断一个人的能力时没有涉及。</p>

<p>有趣的是，我们在考虑其它语言并不会疏忽这一点。一个Rails开发人员并不会仅仅因为他的代码规范而被认为是一个好的开发者。代码规范只是最基本的要求。当然，我们必须考虑代码规范的问题，除此之外，代码的价值（merit）更应该体现在以下几个方面：是否是可读的？是否容易修改或者扩展？是否与应用的其他模块耦合度比较低？是否是可伸缩的（scale）？</p>

<p>这些问题在判断其他代码的好坏时自然而然的被考虑进去，CSS不应该例外。现在的WEB应用程序比以前复杂不少，因此没有经过深思熟虑的CSS架构将导致应用程序的不完美。是时候在考虑应用程序其它代码的优良的同时考虑CSS代码的好坏。不能再遇到问题时，做“事后诸葛亮”，或者仅仅因为设计者的问题而撤销。</p>

<h3>良好的CSS架构的目标</h3>

<p>在CSS技术社区，最佳实践方案很难得到统一。仅仅从<a href="https://news.ycombinator.com/item?id=2658948">黑客新闻(Hacker News)</a>的评论和一个<a href="http://csslint.net/">CSS Lint</a>新版本发布时<a href="http://2002-2012.mattwilcox.net/archive/entry/id/1054/">开发者的反应中</a>就可以很清楚的看到：很多人对CSS开发者应该做什么、不应该做什么这些基础的事都存在很大的争议。
因此，与其讨论我个人认为最佳的实践，不如从定义我们的目标开始。如果我们在目标上能够达成一致，我们就可以开始讨论CSS中不好的实践方案，不是因为它打破了我们潜意识中的“好的实践”的观念，而是因为它阻碍了我们开发的进度。</p>

<p>我认为好的CSS架构的目标应该与其他任何好的软件开发的目标并没有什么不同。我想使我的CSS代码是可见的、可重用的、可维护的、可伸缩的。</p>

<h6>可见性(PREDICTABLE)</h6>

<p>可见性是指你写的CSS规则是与你的期望是一致的。当你添加或修改一条CSS规则时，它不应该影响你所认为的它不应该影响的网站的其它的部分。对于一个小网站来说，它不怎么重要，但当一个网站涉及到成十上百个页面时，可见性就是必须的了。</p>

<h6>重用性(REUSABLE)</h6>

<p>CSS规则应该是可抽取、可分离的，以至于你可以快速的从已有的代码中新建组件，而不是重新新建样式，并且保证不会出现你已解决的问题。</p>

<h6>可维护(MAINTAINABLE)</h6>

<p>可维护性是指当一个新组件或新的风格需要添加时，或者更新或重新布置你的站点时，不需要也不应该重构你的CSS规则即可完成任务。例如：添加组件X时，不应该只因为添加了组件X，而影响了组件Y。</p>

<h6>伸缩性(SCALABLE)</h6>

<p>当你的网站不断增加规模和复杂度时，通常需要更多的开发人员来进行维护。而伸缩性是指出现此种情况时，一个人或一个稍大点的工程团队就可以轻松的管理。也就是说，你的网站的CSS架构在一个人没有较为系统的学习的情况下就很容易理解。这是因为你是唯一 一位在今天接触此代码的人，你却不能保证你会一直维护此段代码。</p>

<h3>公认的不好的习惯(Common Bad Practices)</h3>

<p>在我们看一些如何构造好的CSS架构的方式之前，我想先看看一些不好的习惯是很有帮助的。这些不好的习惯只有经历多次错误之后才能得到好的解决方式。</p>

<p>以下几个事例都是我实际写过的普通的案例，尽管在技术上是有效的，但每一个都可能会导致错误而令人头疼不已。即使我的期望是这次要来点不一样的，但每一次这些样式总都令我陷入困境中。</p>

<h6>基于父节点修改元素</h6>

<p>在几乎所有的WEB站点上，都有特定的视觉元素以至于能够看起来和其所发生的场景保持一致，除了一个。在处理这个“不合群”的元素时，不管是新人还是熟练运用CSS的人几乎使用同一种方法处理。即使用“其独一无二的父元素”或者“新建一个类或ID”来为这个特别的元素新建样式。例如下面这个例子：</p>

<p>In almost every site on the web there will be a particular visual element that looks exactly the same with each occurrence, except one. And when faced with this one-off situation almost every new CSS developer (and even experienced ones) handles it the same way. You figure out some unique parent for this one particular occurrence (or you create one), and you write a new rule to handle it.</p>

<pre><code>.widget {
    background: yellow;
    border: 1px solid black;
    color: black;
    width: 50%;
}

#sidebar .widget {
    width: 200px;
}

body.homepage .widget {
    background: white;
}
</code></pre>

<p>咋一看，上述代码还行，但是，让我们来上述几个目标来分析一下它。</p>

<p>At first this might seem like fairly harmless code, but let’s examine it based on the goals established above.</p>

<p>首先，例子中的 widget 是不可预测的。当一个开发人员写了几个 widget ，期望它们能够看起来一样，但当使用在 “id为sidebar”(#sidebar) 或者“在主页上使用”时，看起来就不一样了，尽管标记是一样的。</p>

<p>First, the widget in the examle is not predictable. A developer who’s made several of these widgets will expect it to look a certain way, yet when she uses it in the sidebar or on the homepage, it will look different, despite the markup being exactly the same.</p>

<p>它也是不可重用或者不可扩展的。当其在主页上以某种样式显示时，其他页面上又需要做什么呢？新的CSS样式不得不添加。</p>

<p>It’s also not very reusable or scalable. What happens when the way it looks on the homepage is requested on some other page? New rules will have to be added.</p>

<p>最后，它也是不可维护的，因为当这个 widget 需要重新设计的时候，不得不在几个地方修改CSS代码，并且，与上面例子不同的是，与其他相比，新提交的规则几乎都不会显示正确。</p>

<p>Lastly, it’s not easily maintainable because if the widget were to get redesigned, it would have to get updated in several places in the CSS, and unlike the above example, the rules that commit this particular anti-pattern rarely appear right next to each other.</p>

<p>Imagine if this type of coding were done in any other language. You’re essentially making a class definition, and then in another part of the code you’re reaching into that class definition and changing it for a particular use case. This directly violates the open/closed principle of software development:</p>

<blockquote><p>软件实体（例如类、模型、函数等）应该是易扩展的，但应是不能修改的；</p>

<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p></blockquote>

<p>后面我们将看到如何不依靠父选择器来进行修改组件；</p>

<p>Later in this article we’ll look at how to modify components without relying on parent selectors.</p>

<h6>过于复杂的选择器</h6>

<p>Occasionally an article will make its way around the Internet showcasing the power of CSS selectors and proclaiming that you can style an entire site without using any classes or IDs.</p>

<p>While technically true, the more I develop with CSS, the more I stay away from complex selectors. The more complicated a selector the more coupled it is to the HTML. Relying on HTML tags and combinators keeps your HTML squeaky clean, but it makes your CSS gross and dirty.</p>

<pre><code>#main-nav ul li ul li div { }
#content article h1:first-child { }
#sidebar &gt; div &gt; h3 + p { }
</code></pre>

<p>All of the above examples make logical sense. The first is probably styling a dropdown menu, the second says that the article’s main heading should look different than all other h1 elements, and the last example is likely adding some extra spacing for the first paragraph in the sidebar sections.</p>

<p>If this HTML were never going to change, an argument could be made for its merits, but how realistic is it to assume the HTML will never change? Overly complicated selectors can be impressive and they can rid the HTML of all presentational hooks, but they rarely help us achieve our goals for good CSS architecture.</p>

<p>These examples above are not reusable at all. Since the selector is pointing to a very particular place in the markup, how could another component with a different HTML structure reuse those styles? Taking the first selector (the dropdown) as an example, what if a similar looking dropdown were needed on a different page and it wasn’t inside of the #main-nav element? You’d have to recreate the entire style.</p>

<p>These selectors are also very unpredictable if the HTML needs to change. Imagine that a devloper wanted to change the div in the third example to the HTML5 section tag, the whole rule would break.</p>

<p>Finally, since these selectors only work when the HTML remains constant, they’re by definition not maintainable or scalable.</p>

<p>In large applictaions you have to make trade-offs and compromises. The fragility of complex selectors are rarely worth the price in the name of keeping your HTML “clean”.</p>

<h6>过多的类名(OVERLY GENERIC CLASS NAMES)</h6>

<p>When creating reusable design components, it’s very common to scope (as it were) the component’s sub-elements inside the component’s class name. For example:</p>

<pre><code>&lt;div class="widget"&gt;
    &lt;h3 class="title"&gt;...&lt;/h3&gt;
    &lt;div class="contents"&gt;
        Lorem ipsum dolor sit amet, consectetur adipiscing elit.
        In condimentum justo et est dapibus sit amet euismod ligula ornare.
        Vivamus elementum accumsan dignissim.
        &lt;button class="action"&gt;Click Me!&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;

.widget {}
.widget .title {}
.widget .contents {}
.widget .action {}
</code></pre>

<p>The idea is that the .title, .contents, and .action sub-element classes can be safely styled without having to worry about those styles spilling over to any other elements styled with the same classes. This is true, but it doesn’t prevent the styling of classes with those same names from spilling into this component.</p>

<p>On a large project it’s very likely that a class name like .title would get used in another context or even by itself. If that happened, the widget’s title would suddenly look very different than intended.</p>

<p>Overly generic class names lead to very unpredictable CSS.</p>

<h6>MAKING A RULE DO TOO MUCH</h6>

<p>Sometimes you make a visual component that needs to be 20 pixels from the top left corner of a section in your site:</p>

<pre><code>.widget {
    position: absolute;
    top: 20px;
    left: 20px;
    background-color: red;
    font-size: 1.5em;
    text-transform: uppercase;
}
</code></pre>

<p>Then down the road you need to use this exact same component in a different location. The above CSS won’t work because it’s not reusable in different contexts.</p>

<p>The problem is that you’re making this one selector do too much. You’re defining the look and feel as well as the layout and position within the same rule. The look and feel is reusable but the layout and position is not. And since they’re used together, the whole rule is compromised.</p>

<p>While this may seem harmless at first, it often leads to copying and pasting from less CSS-savvy developers. If a new team member wants something to look like a particular component, say an .infobox, they’ll probably start by trying that class. But if that doesn’t work because it positions that new infobox in an undesired way, what are they likely to do? In my experience, most new developers will not break the rule up into its reusable parts. Instead they’ll simply copy and paste the lines of code needed for this particular instance into a new selector, unnecessarily duplicating code.</p>

<h3>The Cause</h3>

<p>All of the above bad practices share one similarity, they place far too much of the styling burden on the CSS.</p>

<p>That may seem like strange statement. After all, it is a stylesheet; shouldn’t it bear most (if not all) of the styling burden? Isn’t that what we want?</p>

<p>The simple answer to this question is “yes”, but, as usual, things aren’t always so simple. Separating content from presentation is a good thing, but just because your CSS is separate from your HTML doesn’t mean your content is separate from your presentation. Put another way, striping all presentational code from your HTML doesn’t fulfill the goal if your CSS requires an intimate knowledge of your HTML structure in order to work.</p>

<p>Furthermore, HTML is rarely just content; it’s almost always structure too. And often that structure consists of container elements with no purpose other than to allow the CSS to isolate a certain group of elements. Even without presentational classes, this is still clearly presentation mixed into the HTML. But is it necessarily mixing presentation with content?</p>

<p>I believe, given the current state of HTML and CSS, it’s necessary and often wise to have the HTML and CSS work together as a presentational layer. The content layer can still be abstracted away via templates and partials.</p>

<h3>The Solution</h3>

<p>If your HTML and your CSS are going to work together to form the presentation layer of a web application, they need to do so in a way that promotes all of the principles of good CSS architecture.</p>

<p>The best approach that I’ve found is for the CSS include as little HTML structure as possible. The CSS should define how a set of visual elements look and (in order to minimize coupling with the HTML) those elements should look as they’re defined regardless of where they appear in the HTML. If a certain component needs to look different in a different scenario, it should be called something different and it’s the HTML’s responsibility to call it that.</p>

<p>As an example, the CSS might define a button component via the .button class. If the HTML wants a particular element to look like a button, it should use that class. If there’s a situation were the button needs to look different (perhaps larger and full-width), then the CSS needs to define that look as well with a new class, and the HTML can include that new class to employ the new look.</p>

<p>The CSS defines what your components look like, and the HTML assigns those looks to the elements on the page. The less the CSS needs to know about the HTML structure the better.</p>

<p>A huge benefit of declaring exactly what you want in the HTML is it allows other developers to look at the markup and know exactly what the element is supposed to look like. The intent is obvious. Without this practice it’s impossible to tell if the look of an element is intentional or accidental, and this leads to confusion on the team.</p>

<p>A common objection to putting a lot of classes in the markup is the extra effort required to do so. A single CSS rule could target a thousand instances of a particular component. Is it really worth writing that classes a thousand times just to have it explicitly declared in the markup?</p>

<p>While this concern is clearly valid, it can be misleading. The implication is that either you use a parent selector in the CSS or you write that HTML class 1000 times by hand, but there are obviously other alternatives. View level abstractions in Rails or other frameworks can go a long way toward keeping the visual look explicitly declared in the HTML without having to write the same class over and over again.</p>

<h3>Best Practices</h3>

<p>After making the above mistakes over and over again, and paying the consequences later on down the road, I’ve come up with the following bits of advice. While by no means comprehensive, my experience has shown that sticking to these principles will help you better achieve the goals of good CSS architecture.</p>

<h6>BE INTENTIONAL</h6>

<p>The best way to make sure your selectors don’t style unwanted elements is to not give them the opportunity. A selector like #main-nav ul li ul li div could very easily end up applying to unwanted elements as your markup changes down the road. A style like .subnav, on the other hand, will have absolutely no chance of accidentally applying to an unwanted element. Applying classes directly to the elements you want to style is the best way to keep your CSS predictable.</p>

<pre><code>/* Grenade */
#main-nav ul li ul { }

/* Sniper Rifle */
.subnav { }
</code></pre>

<p>Given the two examples above, think of the first one like a grenade and the second like a sniper rifle. The grenade might work just fine today, but you never know when an innocent civilian could move inside the blast radius.</p>

<h6>SEPARATE YOUR CONCERNS</h6>

<p>I’ve already mentioned that a well organized component layer can help loosen the coupling of HTML structure in the CSS. In addition to that, your CSS components themselves should be modular. Components should know how to style themselves and do that job well, but they should not be responsible for their layout or positioning nor should they make too many assumptions about how they’ll be spaced in relation to surrounding elements.</p>

<p>In general, components should define how they look, but not their layout or position. Be careful when you see properties like background, color, and font in the same rule as position, width, height, and margin.</p>

<p>Layout and position should be handled by either a separate layout class or a separate container element. (Remember that to effectively separate content from presentation it’s often essential to separate content from its container.)</p>

<h6>NAMESPACE YOUR CLASSES</h6>

<p>We already examined why parent selectors aren’t 100% effective at encapsulation and preventing style cross-contamination. A much better approach is applying namespaces to the classes themselves. If an element is a member of a visual component, every one of its sub-element classes should use the component’s base class name as a namespace.</p>

<pre><code>/* High risk of style cross-contamination */
.widget { }
.widget .title { }

/* Low risk of style cross-contamination */
.widget { }
.widget-title { }
</code></pre>

<p>Namespacing your classes keeps your components self-contained and modular. It minimizes the likelihood that an existing class will conflict, and it lowers the specificity required to style child elements.</p>

<h6>EXTEND COMPONENTS WITH MODIFIER CLASSES</h6>

<p>When an existing component needs to look slightly different in a certain context, create a modifier class to extend it.</p>

<pre><code>/* Bad */
.widget { }
#sidebar .widget { }

/* Good */
.widget { }
.widget-sidebar { }
</code></pre>

<p>We’ve already seen the downsides of modifying components based on one of their parent elements, but to reiterate: A modifier class can be used anywhere. Location based overrides can only be used in a specific location. Modifier classes can also be reused as many times as you need. Lastly, modifier classes express the intention of the developer very clearly right in the HTML. Location based classes, on the other hand, are completely invisible to a developer only looking at the HTML, greatly increasing the probability that it will be overlooked.</p>

<h6>ORGANIZE YOUR CSS INTO A LOGICAL STRUCTURE</h6>

<p><a href="http://snook.ca/">Jonathan Snook</a>, in his excellent book <a href="http://smacss.com/">SMACSS</a>, argues for organizing your CSS rules into four separate categories: base, layout, modules, and state. Base consists of reset rules and element defaults. Layout is for positioning of site-wide elements as well as generic layout helpers like grid systems. Modules are reusable visual elements, and state refers to styling that can be toggled on or off via JavaScript.</p>

<p>In the SMACSS system, modules (which are equivalent to what I call components) comprise the vast majority of all the CSS rules, so I often find it necessary to break them down even further into abstract templates.</p>

<p>Components are standalone visual elements. Templates, on the other hand, are building blocks. Templates don’t stand on their own and rarely describe look and feel. Instead, they’re single, repeatable patterns that can be put together to form a component.</p>

<p>To provide a concrete example, a component might be a modal dialog box. The modal might have the site’s signature background gradient in the header, it might have a drop shadow around it, it might have a close button in the top right corner, and it might be positioned fixed and centered vertically and horizontally. Each of these four patterns might be used again and again all over the site, so you wouldn’t want to have to recode those patterns each time. As such they’re all templates, and together they comprise the modal component.</p>

<p>I typically don’t use template classes in the HTML unless I have a good reason. Instead I use a preprocessor to include the template styles in the component definition. I’ll discuss this and my rational for doing so in more detail later.</p>

<h6>USE CLASSES FOR STYLING AND STYLING ONLY</h6>

<p>Anyone who has worked on a large project has come across an HTML element with a class whose purpose was completely unknown. You want to remove it, but you’re hesitant because it may have some purpose that you’re not aware of. As this happens again and again, over time, your HTML become filled with classes that serve no purpose just because team members are afraid to delete them.</p>

<p>The problem is that classes are generally given too many responsibilities in front-end web development. They style HTML elements, they act as JavaScript hooks, they’re added to the HTML for feature detections, they’re used in automated tests, etc.</p>

<p>This is a problem. When classes are used by too many parts of the application, it becomes very scary to remove them from your HTML.</p>

<p>However, with an established convention, this problem can be completely avoided. When you see a class in the HTML, you should be able to tell instantly what its purpose is. My recommendation is to give all non-styled classes a prefix. I use .js- for JavaScript and I use .supports- for Modernizr classes. All classes without a prefix are for styling and styling only.</p>

<p>This makes finding unused classes and removing them from the HTML as easy as searching the stylesheets directory. You can even automate this process in JavaScript by cross referencing the classes in the HTML with the classes in the document.styleSheets object. Classes that aren’t in document.styleSheets can be safely removed.</p>

<p>In general, just as it’s a best practice to separate your content from your presentation, it’s also important to separate your presentation from your functionality. Using styled classes as JavaScript hooks deeply couples your CSS and JavaScript in a way that can make it hard or impossible to update the look of certain elements without breaking functionality.</p>

<h6>NAME YOUR CLASSES WITH A LOGICAL STRUCTURE</h6>

<p>These days most people write CSS with hyphens as word separators. But hyphens alone are usually not enough to distinguish between different types of classes.</p>

<p><a href="http://nicolasgallagher.com/">Nicolas Gallagher</a> recently wrote about <a href="http://nicolasgallagher.com/about-html-semantics-front-end-architecture/">his solution to this problem</a> which I have also adopted (with slight changes) with great success. To illustrate the need for a naming convention consider the following:</p>

<pre><code>/* A component */
.button-group { }

/* A component modifier (modifying .button) */
.button-primary { }

/* A component sub-object (lives within .button) */
.button-icon { }

/* Is this a component class or a layout class? */
.header { }
</code></pre>

<p>From looking at the above classes, it’s impossible to tell what type of rule they apply to. This not only increases confusion during development, but it also makes it harder to test your CSS and HTML in an automated way. A structured naming convention allows you to look at a class name and know exactly what its relationship is to other classes and where it should appear in the HTML — making naming easier and testing possible where it previously was not.</p>

<pre><code>/* Templates Rules (using Sass placeholders) */
%template-name
%template-name--modifier-name
%template-name__sub-object
%template-name__sub-object--modifier-name

/* Component Rules */
.component-name
.component-name--modifier-name
.component-name__sub-object
.component-name__sub-object--modifier-name

/* Layout Rules */
.l-layout-method
.grid

/* State Rules */
.is-state-type

/* Non-styled JavaScript Hooks */
.js-action-name
</code></pre>

<p>The first example redone:</p>

<pre><code>/* A component */
.button-group { }

/* A component modifier (modifying .button) */
.button--primary { }

/* A component sub-object (lives within .button) */
.button__icon { }

/* A layout class */
.l-header { }
</code></pre>

<h3>Tools</h3>

<p>Maintaining an effective and well-organized CSS architecture can be very difficult, especially on large teams. A few bad rules here and there can snowball into an unmanageable mess. Once your application’s CSS has entered into the realm of specificity wars and !important trumps, it can be next to impossible to recover without starting over. The key is to avoid those problems from the beginning.</p>

<p>Fortunately, there are tools that can make controlling your site’s CSS architecture much easier.</p>

<h6>PREPROCESSORS</h6>

<p>These days it’s impossible to talk about CSS tools without mentioning preprocessors, so this article won’t be any different. But before I praise their usefulness, I should offer a few words of caution.</p>

<p>Preprocessors help you write CSS faster, not better. Ultimately it gets turned into plain CSS, and the same rules should apply. If a preprocessor lets you write your CSS faster then it also lets you write bad CSS faster, so it’s important to understand good CSS architecture before thinking a preprocessor will solve your problems.</p>

<p>Many of the so-called “features” of preprocessors can actually be very bad for CSS architecture. The following are some of the “features” I avoid at all costs (and though the general ideas apply to all preprocessor languages, these guidelines apply specifically to Sass).</p>

<ul>
<li>Never nest rules purely for code organization. Only nest when the outputted CSS is what you want.</li>
<li>Never use a mixin if you’re not passing an argument. Mixins without arguments are much better used as templates which can be extended.</li>
<li>Never use @extend on a selector that isn’t a single class. It doesn’t make sense from a design perspective and it bloats the compiled CSS.</li>
<li>Never use @extend for UI components in component modifier rules because you lose the inheritance chain (more on this in a bit).</li>
</ul>


<p>The best parts of preprocessors are functions like <a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#extend">@extend</a> and <a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#placeholder_selectors_">%placeholder</a>. Both allow you to easily manage CSS abstraction without adding bloat to your CSS or a huge list of base classes in your HTML that can be very hard to manage.</p>

<p>@extend should be used with care though because sometime you want those classes in your HTML. For example, when you first learn about @extend it might be tempting to use it with all of your modifier classes like so:</p>

<pre><code>.button {
  /* button styles */
}

/* Bad */
.button--primary {
  @extend .button;
  /* modification styles */
}
</code></pre>

<p>The problem with doing this is you lose the inheritance chain in the HTML. Now it’s very difficult to select all button instances with JavaScript.</p>

<p>As a general rule, I never extend UI components or anything that I might want to know the type of later. This is what templates are for and another way to help distinguish between templates and components. A template is something you wouldn’t ever need to target in your application logic, and therefore can be safely extended with a preprocessor.</p>

<p>Here’s how it might look using the modal example referenced above:</p>

<pre><code>.modal {
  @extend %dialog;
  @extend %drop-shadow;
  @extend %statically-centered;
  /* other modal styles */
}

.modal__close {
  @extend %dialog__close;
  /* other close button styles */
}

.modal__header {
  @extend %background-gradient;
  /* other modal header styles */
}
</code></pre>

<h6>CSS LINT</h6>

<p><a href="http://www.stubbornella.org/">Nicole Sullivan</a> and <a href="http://www.nczonline.net/">Nicholas Zakas</a> created <a href="http://csslint.net/">CSS Lint</a> as a code quality tool to help developers detect bad practices in their CSS. Their site describes it as such:</p>

<blockquote><p>CSS Lint points out problems with your CSS code. It does basic syntax checking as well as applying a set of rules to the code that look for problematic patterns or signs of inefficiency. The [rules] are all pluggable, so you can easily write your own or omit ones you don’t want.</p></blockquote>

<p>While the general ruleset may not be perfect for most projects, the best feature of CSS Lint is its ability to be customized exactly how you want it. This means you can pick and choose the rules you want from their default list as well as write your own.</p>

<p>A tool like CSS Lint is essential for any large team to ensure at least a baseline of consistency and convention compliance. And like I hinted at previously, one of the great reasons for conventions is they allow for tools like CSS Lint to easily identify anything that breaks them.</p>

<p>Based on the conventions I’ve proposed above, it becomes very easy to write rules to detect particular antipatterns. Here are a few suggestions that I use:</p>

<ul>
<li>Don’t allow IDs in your selectors.</li>
<li>Don’t use non-semantic type selectors (e.g. DIV, SPAN) in any multi-part rule.</li>
<li>Don’t use more than 2 combinators in a selector.</li>
<li>Don’t allow any class names that begin with “js-”.</li>
<li>Warn if frequently using layout and positioning for non “l-” prefixed rules.</li>
<li>Warn if a class defined by itself is later redefined as a child of something else.</li>
</ul>


<p>These are obviously just suggestions, but they’re intended to get you thinking about how to enforce the standards you want on your projects.</p>

<h6>HTML INSPECTOR</h6>

<p>Earlier I suggested that it would be easy to search your HTML classes and all linked stylesheets and warn if a class was used in the HTML but not defined in any stylesheet. I’m currently developing a tool called the <a href="https://github.com/philipwalton/html-inspector">HTML Inspector</a> to make this process easier.</p>

<p>HTML Inspector traverses your HTML and (much like CSS Lint) allows you to write your own rules that throw errors and warnings when some convention is being broken. I currently use the following rules:</p>

<ul>
<li>Warn if the same ID is used more than once on a page.</li>
<li>Don’t use any classes that aren’t mentioned in any stylesheet or pass a whitelist (like “js-” prefixed classes).</li>
<li>Modifer classes shouldn’t be used without their base class.</li>
<li>Sub-object classes shouldn’t be used when no ancestor contains the base class.</li>
<li>Plain old DIV or SPAN elements, without classes attached, should not be used in the HTML.</li>
</ul>


<h3>Summary</h3>

<p>CSS isn’t just visual design. Don’t throw out programming best practices just because you’re writing CSS. Concepts like OOP, DRY, the open/closed principle, separation of concerns, etc. still apply to CSS.</p>

<p>The bottom line is that whatever you do to organize your code, make sure you judge your methods by whether or not they actually help make your development easier and more maintainable in the long term.</p>

<h3>About the Author</h3>

<p><a href="http://philipwalton.com">Philip Walton</a> is a Front End Software Engineer at AppFolio. For more of this thoughts you can read his blog or <a href="http://twitter.com/philwalton">follow him</a> on Twitter:</p>

<p><a href="http://philipwalton.com">http://philipwalton.com</a></p>

<p><a href="http://twitter.com/philwalton">@philwalton</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译文] 使用 HTML5 Canvas 创建一个拾色器]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/05/17/color-picker-canvas/"/>
    <updated>2013-05-17T21:47:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/05/17/color-picker-canvas</id>
    <content type="html"><![CDATA[<blockquote><p>创建 Canvas 应用是一件有意思且新奇的事情，甚至可以创建游戏；Canvas 在大多数的桌面和手机浏览器中都能够很好的支持，是比使用 Flash 更可行的解决方案；</p></blockquote>

<p>本例中使用HTML5中 Canvas 来创建一个简易的拾色器（color picker），在此过程中，不需要任何的 Flash，有一个“文本编辑器”和一个“浏览器”即可。</p>

<p>开始之前，您可以在“<a href="http://netdna.webdesignerdepot.com/uploads7/how-to-create-a-color-picker-with-html5-canvas/demo/"><strong>这里</strong></a>”看看我们将要创建的应用的效果，您也可以在“<a href="http://netdna.webdesignerdepot.com/uploads7/how-to-create-a-color-picker-with-html5-canvas/demo/demo.zip"><strong>这里</strong></a>”下载源文件。
<em>如果您在本地测试这个实例，最好不要使用 Chrome 浏览器，因为 Chrome 的安全模块要求 script 只在线上工作（only work online）。</em></p>

<h3>HTML</h3>

<p>在这个例子中，HTML 使用的不多，我们需要做的就是创建<strong>一个Canvas</strong>，然后有<strong>两个文本框</strong>用于放置所点击颜色的 RGB 表示和 16 进制颜色值表示；代码如下:</p>

<pre><code>&lt;canvas width="600" height="440" id="canvas_picker"&gt;&lt;/canvas&gt;
&lt;div id="hex"&gt;HEX: &lt;input type="text"&gt;&lt;/input&gt;&lt;/div&gt;
&lt;div id="rgb"&gt;RGB: &lt;input type="text"&gt;&lt;/input&gt;&lt;/div&gt;
</code></pre>

<p>由于我们在一张背景图片拾取颜色，因此把 Canvas 的高度和宽度设置成了背景图片的高度和宽度；所点击的颜色显示在两个文本框中；</p>

<p>由于我们要用到 jQuery，因此代码中要包含jQuery库。</p>

<h3>JavaScript</h3>

<p>要使拾色器工作，首先，我们需要做的是获取 Canvas 和它的上下文，我们可以用一句代码，像这样：</p>

<pre><code>var canvas = document.getElementById('canvas_picker').getContext('2d');
</code></pre>

<p>紧接着，我们需要做的就是给 Canvas 元素设置一张背景图片，此过程中，我们需要创建一个 image 对象，并设置其 URL 属性，当图片加载完毕后，加载到 Canvas 中，代码如下：</p>

<pre><code>var img = new Image();
img.src = 'image.jpg';
$(img).load(function(){
    canvas.drawImage(img,0,0);
});
</code></pre>

<p>下面我们应该考虑的是：当鼠标点击事件在 Canvas 中发生时，我们应该捕捉到该事件，并且获取用户点击鼠标的位置，代码可以这样写：</p>

<pre><code>$('#canvas_picker').click(function(event){
    var x = event.pageX - this.offsetLeft;
    var y = event.pageY - this.offsetTop;
});
</code></pre>

<p>这两句代码的意思是获取用户点击的位置，我们所需做的就是获取其坐标，并减去 Canvas 元素的偏移量(offsetLeft 和 offsetTop)； 这样就得到了相对于 Canvas 用户点击的位置；</p>

<p>下一步就是获取用户点击位置的 RGB 值，我们需要用到 getImageData() 函数，并把上面代码中 x，y 值传递进去：</p>

<pre><code>$('#canvas_picker').click(function(event){
    var x = event.pageX - this.offsetLeft;
    var y = event.pageY - this.offsetTop;

    var imgData = canvas.getImageData(x, y, 1, 1).data;
    var R = imgData[0];
    var G = imgData[1];
    var B = imgData[2];

});
</code></pre>

<p>接下来就是把 RGB 值显示给用户：</p>

<pre><code>$('#canvas_picker').click(function(event){
    var x = event.pageX - this.offsetLeft;
    var y = event.pageY - this.offsetTop;

    var imgData = canvas.getImageData(x, y, 1, 1).data;
    var R = imgData[0];
    var G = imgData[1];
    var B = imgData[2];

    var rgb = R + ',' + G + ',' + B;
    $('#rgb input').val(rgb);

});
</code></pre>

<p>现在已经可以得到用户点击位置的 RGB 值，不过，为了有更好的体验，我们同时显示点击位置的 16 进制值颜色值，把 RGB 值转换为 16 进制颜色值的代码如下：</p>

<pre><code>function rgbToHex(R,G,B) {return toHex(R)+toHex(G)+toHex(B)}
function toHex(n) {
    n = parseInt(n,10);
    if (isNaN(n)) 
        return "00";
    n = Math.max(0,Math.min(n,255));
    return "0123456789ABCDEF".charAt((n-n%16)/16) + "0123456789ABCDEF".charAt(n%16);
}
</code></pre>

<p>我们已经完成了本例子的大部分功能，下面就是把16进制颜色值显示在文本框中：</p>

<pre><code>var hex = rgbToHex(R,G,B);
$('#hex input').val('#' + hex);
</code></pre>

<h3>完整代码</h3>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;拾色器事例代码&lt;/title&gt;
    &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;canvas width="600" height="440" id="canvas_picker"&gt;&lt;/canvas&gt;
&lt;div id="hex"&gt;HEX: &lt;input type="text"&gt;&lt;/input&gt;&lt;/div&gt;
&lt;div id="rgb"&gt;RGB: &lt;input type="text"&gt;&lt;/input&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;
    var canvas = document.getElementById('canvas_picker').getContext('2d');

    // 创建一个 image 对象
    var img = new Image();
    img.src = 'image.jpg';

    // 把图片设置到Canvas中
    $(img).load(function(){
        canvas.drawImage(img,0,0);
    });

    // RGB 转换成 HEX
    function rgbToHex(R,G,B) {return toHex(R)+toHex(G)+toHex(B)}
    function toHex(n) {
         n = parseInt(n,10);
         if (isNaN(n)) return "00";
         n = Math.max(0,Math.min(n,255));
         return "0123456789ABCDEF".charAt((n-n%16)/16)  + "0123456789ABCDEF".charAt(n%16);
    }
    $('#canvas_picker').click(function(event){
        // 获取用户点击坐标
        var x = event.pageX - this.offsetLeft;
        var y = event.pageY - this.offsetTop;
        // 获取 RGB 值
        var img_data = canvas.getImageData(x, y, 1, 1).data;
        var R = img_data[0];
        var G = img_data[1];
        var B = img_data[2];  var rgb = R + ',' + G + ',' + B;
        // RGB 转成 HEX
        var hex = rgbToHex(R,G,B);
        // 显示颜色值
        $('#rgb input').val(rgb);
        $('#hex input').val('#' + hex);
    });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>总结</h3>

<p>通过本事例我们应该意识到使用 Canvas 创建应用有很大的潜力；在其他地方有很多更好的例子，甚至很多人用Canvas 做游戏，Canvas 的巨大潜能等待你的挖掘。</p>

<h3>原文地址</h3>

<p><a href="http://www.webdesignerdepot.com/2013/03/how-to-create-a-color-picker-with-html5-canvas/">How to create a color picker with HTML5 Canvas</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 中“闭包”浅析]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/05/17/javascript-closure/"/>
    <updated>2013-05-17T19:07:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/05/17/javascript-closure</id>
    <content type="html"><![CDATA[<blockquote><p>闭包(Closure)是 JavaScript 的一大特色，也是一大难点，很多高级应用中需要深入理解闭包，才能写出高效的程序；本文依据作者所看过的资料，根据自己的理解来阐述 JavaScript 中的“闭包”。如文章中有错误或不恰当之处，望不吝赐教！</p></blockquote>

<h3>JavaScript 中为什么需要“闭包”</h3>

<p>要理解 JavaScript 中为什么需要闭包，需要先掌握 JavaScript 中“变量的作用域”问题：</p>

<pre><code>var global = 10;
function fun1(){
    var num = 100;
    console.log(global);   //10
    console.log(num);      //100
}
fun1();
console.log(global);       //10
console.log(num);          //ERROR : num is not defined 
</code></pre>

<p>“变量的作用域”无非就两种：全局作用域和局部作用域；根据变量的作用域可知，函数内部可以直接读取全局变量，而函数外部无法读取函数内的局部变量（因为在一个函数执行完毕以后，函数所依赖的执行空间会被回收，函数内部的局部变量也被销毁）；虽然可以通过函数的返回值得到一个函数内部变量的值，但有多个变量时我们无法下手，并且我们得到的并不是局部变量本身，而是局部变量在函数内部运行后的值。</p>

<p>我们有时需要得到函数内部的局部变量，因此这就引出一个问题：如何读取函数内部的局部变量？</p>

<p>例如以下一段代码:</p>

<pre><code>function fun1(){
    var num = 100;
    function fun2(){
        var num2 = 1000;
        console.log(num);    //100;
    }
    console.log(num2);       //ERROR : num is not defined 
}
</code></pre>

<p>有过丁点编程经验的人都应该明白，在上述代码中，函数 fun2() 理所当然能够得到变量 num 的值，fun1() 不能取得 fun2() 内部定义的局部变量，这一点，我们在后面会通过 JavaScript 的“作用域链”给出解释；</p>

<p>再来看一段代码：</p>

<pre><code>function fun1(){
    var num1 = 100;
    var num2 = 200;
    function fun2(){
        console.log(num1);     //100
        console.log(num2);     //200
    }
    return fun2;
}

var num = fun1();
num();
</code></pre>

<p>上述代码显示：fun2() 访问了定义在 fun1() 中的两个变量，即说明 fun2() 能够读取 fun1() 定义的局部变量；为了读取函数内部的局部变量，我们在函数内部又定义了一个函数，我们就把 fun2() 这样的函数称之为“闭包”；</p>

<h3>闭包的定义</h3>

<p>专业文献上的“闭包”（closure）定义非常抽象，很难看懂。</p>

<p>可以根据上述定义把闭包描述为：闭包就是能够读取其他函数内部变量的函数。</p>

<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成：定义在一个函数内部的函数。</p>

<h3>闭包的用途</h3>

<p>闭包常见的两大用途：一是可以读取函数内部的变量，一是让这些变量的值始终保持在内存中。</p>

<p>要理解第二句话，看下面一段代码：</p>

<pre><code>function fun1(){
    var num = 999;
    numAdd = function(){num+=1;}
    function fun2(){
        alert(num);
    }
    return fun2;
}
var result=fun1();
result();        // 999
numAdd();
result();        // 1000
</code></pre>

<p>在这段代码中，result 实际上就是闭包 fun2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 fun1 中的局部变量 num 一直保存在内存中，并没有在 fun1 调用后被自动清除。</p>

<p>为什么会这样呢？原因就在于 fun1 是 fun2 的父函数，而 fun2 被赋给了一个全局变量，这导致 fun2 始终在内存中，而 fun2 的存在依赖于 fun1 ，因此 fun1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>

<p>这段代码中另一个值得注意的地方，就是 “numAdd=function(){num+=1}” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 numAdd 是一个全局变量，而不是局部变量。其次，numAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 numAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p>

<h3>待续&#8230;&#8230;</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[脚本异步加载、顺序执行技术(临时稿)]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/04/23/js-ansy-load/"/>
    <updated>2013-04-23T16:01:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/04/23/js-ansy-load</id>
    <content type="html"><![CDATA[<h3>无阻塞加载脚本</h3>

<p>（1）XHR Eval 技术：该技术主要通过 XMLHttpRequest 对象从服务器端获取脚本</p>

<pre><code>var xhrObject = getXHRObject();

xhrObject.onreadystatechange = function(){
    if(xhrObject.readyState == 4 &amp;&amp; 200 == xhrObject.status){
        //响应完成时，通过 eval() 执行内容
        eval(xhrObject.responseText);
    }
};

//必须和主页面在一个域中
xhrObject.open('GET', 'A.js', true);
xhrObject.send('');

//获取 XMLHttpRequest 对象
function getXHRObject(){
    var xhrObject = false ;
    try {
        xhrObject = new XMLHttpRequest();
    }
    catch(e){
        var progid = ['MSXML2.XMLHTTP.5.0', 
                      'MSXML2.XMLHTTP.4.0', 
                      'MSXML2.XMLHTTP.3.0', 
                      'MSXML2.XMLHTTP', 
                      'Microsoft.XMLHTTP'];
        for(var i=0; i &lt; progid.length; ++i){
            try {
                xhrObject = new ActiveXObject(progid[i]);
            }
            catch(e){
                continue ;
            }
            break;
        }
    }
    finally {
        return xhrObject;
    }
}
</code></pre>

<p>（2）XHR 注入 技术：也是通过 XMLHttpRequest 对象从服务器端获取脚本，与 eval 不同的是：该机制通过创建一个 script 的 DOM 元素，然后把 XMLHttpRequest 的响应注入到 script 中来执行 javascript 的；</p>

<pre><code>var xhrObject = getXHRObject();

xhrObject.onreadystatechange = function(){
    if(xhrObject.readyState == 4){
        var scriptElem = document.createElement('script');
        document.getElementsByTagName('head')[0].appendChild(scriptElem);
        scriptElem.text = xhrobject.responseText;
    }
};

//必须和主页面在一个域中
xhrObject.open('GET', 'A.js', true);
xhrObject.send('');
</code></pre>

<h3>异步加载脚本时，如何保持执行顺序问题</h3>

<h5>1、异步加载脚本时，单个外部脚本和行内代码执行顺序解决方案</h5>

<p>（1）Script Onload 技术</p>

<pre><code>采用 Script DOM Element 作为异步加载技术

&lt;script type="text/javascript"&gt;

var aExamples = [['couple-normal.php', 'Normal Script Src'], ...];

function init() {
    EFWS.Menu.createMenu('examplesbtn', aExamples);
}

var domscript = document.createElement('script');
// menu.js 提供生成下拉菜单的功能
domscript.src = "menu.js";
domscript.onloadDone = false;   //防止 Opera 被执行两次
domscript.onload = function(){
    domscript.onloadDone = true;
    init();
};
domscript.onreadystatechange = function(){
    if(("loaded" === domscript.readyState || "complete" === domscript.readyState)&amp;&amp; !domscript.onloadDone){
        domscript.onloadDone = true;
        init();
    }
};

document.getElementsByTagName('head')[0].appendChild(domscript);

&lt;/script&gt;
</code></pre>

<h5>2、异步加载脚本时，多个外部脚本和行内代码执行顺序解决方案</h5>

<p>（1）Managed XHR 技术</p>

<p>（2）DOM Element 和 Document.write 技术</p>

<h3>综合解决方案</h3>

<p>（1）单个脚本</p>

<p>说明：异步加载单个脚本的最佳技术是：Script DOM Element，Script Onload 是整合单个外部脚本和行内脚本的最好选择；</p>

<p>（2）多个脚本</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何编写 jQuery 插件]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/04/19/jqueryplugin/"/>
    <updated>2013-04-19T17:09:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/04/19/jqueryplugin</id>
    <content type="html"><![CDATA[<h3>认识几款基于 jQuery 的插件</h3>

<ul>
<li><a href="http://simplemodal.plasm.it/">SimpleModal</a>：为模态窗口开发提供接口；</li>
<li><a href="http://www.aqee.net/docs/jquery.form.plugin/jquery.form.plugin.html">Form</a>：是一款Ajax表单插件；</li>
<li><a href="http://www.lazyload.com/">LazyLoad</a>：通过延迟加载来实现按需加载，达到节省资源，加快浏览速度的目的;</li>
<li><a href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/">Validation</a>：表单验证插件;</li>
<li><a href="http://jqueryui.com/">jQueryUI</a>：jQuery用户界面插件；</li>
</ul>


<h3>jQuery 插件的种类</h3>

<ol>
<li>封装对象方法的插件：用于通过选择器获取的jQuery对象进行操作(最为常见)；</li>
<li>封装全局函数的插件：将独立的函数加到jQuery命名空间下；</li>
<li>选择器插件：扩充自己喜欢的选择器；</li>
</ol>


<p>主要就是这三种插件比较常用。</p>

<p>jQuery.fn.extend()和jQuery.extend() 是用于扩展 jQuery 功能的两个方法；</p>

<p>其中：</p>

<blockquote><p>jQuery.fn.extend()用于扩展第一种类型的插件，jQuery.extend()用于扩展后两种类型的插件；这两个方法都有一个参数，类型为 Object, Object 对象的“名/值对”分别代表“函数或方法名/函数主体”；</p></blockquote>

<p>jQuery.extend() 还可以扩展已有的 Object 对象；</p>

<pre><code>jQuery.extend(target,obj1,...objN) 

//用一个或多个其他对象扩展一个对象，然后返回被扩展的对象；

例如：
var setting = {validate:false, limit:5, name:"foo"};
var option = {validate:true, name:"bar"};
var newOption = jQuery.extend(setting, option);

结果为：
newOption = {validate:true, limit:5, name:"bar"};
</code></pre>

<p>jQuery.extend() 还可用来设置插件方法的默认参数：</p>

<pre><code>例如：
function foo(option){
    option = jQuery.extend({
        name:"bar",
        length：5，
        dateType:"xml"
    }, option);
};

调用方法如下：
foo({name:"a", length:4， dataType:"json"});
...
foo(name:"a");
foo();
注：传入的是映射而不是参数列表；
</code></pre>

<h3>封装插件时的注意事项：</h3>

<ul>
<li>jQuery插件的命名：一般采用<strong>jQuery.插件名.js</strong>，以免和其他js插件冲突；</li>
<li>所有的对象方法都应附加到 jQuery.fn 对象上，所有的全局函数都应附加到 jQuery 对象本身上</li>
<li>在插件内部，this 指向的是当前通过选择器获取的 jQuery 对象上，而不是 DOM 元素；</li>
<li>可以通过 this.each 遍历所有元素；</li>
<li>所有的方法或函数插件，都应以分好结尾，避免压缩的时候出现问题，甚至应该在插件头部加上分号，避免别人的不规范给插件带来影响；</li>
<li>插件应该返回一个 jQuery 对象，以保证插件的可链式操作，除非插件需要返回的是一些需要获取的量，例如字符串或者数组等；</li>
<li>避免在插件内部使用 $ 作为 jQuery 对象的别名，应使用完整的 jQuery 来表示，以避免冲突；可以利用<strong>闭包</strong>来回避这个问题；</li>
</ul>


<blockquote><p>闭包问题：</p>

<p>(ECMAScript)允许使用内部函数，且内部函数可以访问他们所在的外部函数中声明的所有局部变量、参数和其它内部函数，当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包；</p>

<p>利用闭包的特性，既可以避免内部临时变量影响全局空间，又可以在插件内部继续使用 $ 作为 jQuery 的别名；</p></blockquote>

<p>常见的 jQuery 插件的结构：</p>

<pre><code>//; 作用是更好的兼容性
;(function($){
    //这里放置代码
})(jQuery);     //jQuery 作为实参传递进去
</code></pre>

<h3>编写 jQuery 插件实例</h3>

<blockquote><p>注：在此利用封装 jQuery 对象方法编写一个颜色插件，有两个功能：</p>

<p>一是设置匹配元素的颜色；</p>

<p>一是获取匹配元素（元素集合中的第一个）的颜色。</p></blockquote>

<p>把此插件命名为 jquery.color.js;</p>

<p>首先采用扩展第一类插件的方法进行编写，代码如下:</p>

<pre><code>;(function($){

    $.fn.extend({

        "color" : function(value){
            //这里编写插件代码
            //若提供 value 值，则是设置颜色，否则是获取颜色
        }

    });

})(jQuery);
</code></pre>

<p>下面实现第一个功能，设置颜色；代码如下</p>

<pre><code>;(function($){

    $.fn.extend({

        "color" : function(value){

            //this 指向 jQuery 对象
            //使用 return 是要保证其具有可链接性
            //css() 会返回调用它的对象，在此为 this
            return this.css("color", value);

        }

    });

})(jQuery);
</code></pre>

<p>接着实现第二个功能，获取匹配元素集合中第一个元素的颜色；代码如下：</p>

<pre><code>;(function($){

    $.fn.extend({

        "color" : function(value){

            if(value == undefined)
            {
                //css() 本身具有返回第一个匹配元素的样式值的功能，无需使用 eq()
                return this.css("color");
            }
            else
            {
                return this.css("color", value);
            }

        }

    });

})(jQuery);
</code></pre>

<p>至此，两个功能都已实现；下面着手优化一下：</p>

<pre><code>;(function($){

    $.fn.extend({

        "color" : function(value){

            //css() 具有判断 value 是否为 undefined 的机制，所以可以根据不同的
            //传递参数而返回不同的值；
            return this.css("color", value);

        }

    });

})(jQuery);
</code></pre>

<p>到此，此插件已完成，可自行实验一下。</p>

<p>定义一组插件，可使用如下形式：</p>

<pre><code>;(function($){

    $.fn.extend({

        "color" : function(value){

        }，
        "border" : function(value){
        },
        ...
        "background" : function(value){
        }     //最后一个没有逗号

    });

})(jQuery);
</code></pre>

<h3>参考文献</h3>

<ol>
<li><p>锋利的jQuery(第二版)</p></li>
<li><p><a href="http://www.cnblogs.com/JustinYoung/archive/2010/03/30/jquery-chajian.html">跟我一起学写jQuery插件</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于本博客的几点声明]]></title>
    <link href="http://eniac0001.github.io/blog/blog/2013/04/18/aboutblog/"/>
    <updated>2013-04-18T15:13:00+08:00</updated>
    <id>http://eniac0001.github.io/blog/blog/2013/04/18/aboutblog</id>
    <content type="html"><![CDATA[<ol>
<li>本博客托管到 <a href="http://github.com" title="Github">Github</a> 上，空间和域名解析服务有 Github 提供支持;</li>
<li>本博客系统源码有 <a href="http://octopress.org">Octopress</a> 友情奉献;</li>
<li>本博客主题有 <a href="http://shashankmehta.in/archive/2012/greyshade.html">GreyShade</a> 无偿提供；</li>
<li>评论模块有 <a href="http://duoshuo.com">多说</a> 提供支持；</li>
<li>在此对 “Github、Octopress、GreyShade、多说” 表示感谢；</li>
</ol>


<p>本博客其他地方若涉及到以上内容，均不再作出说明。&circ;&ndash;&circ;</p>
]]></content>
  </entry>
  
</feed>
